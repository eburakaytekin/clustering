% measure cluster widths via polar transform
% measures centers from clusters generated by dbscan
% load bin file generated in clustering step - should include a cluster
% centers in CatInd_centers (2), and clustered molecules indexed by frame
% number
% radius_out saves measured radii as circle which encloses quantile% of
% molecules, e.g. circle containing 95% of molecules in cluster
% units are in px - multiply by px size to convert to nm


quantile = 0.95;

r = OpenMolList;
x=r.xc;
y=r.yc;
z=r.zc;

num_clusters = max(r.frame);

out_radius = zeros(numel(num_clusters),1);
out_avgZ = zeros(numel(num_clusters),1);
out_stdZ = zeros(numel(num_clusters),1);
out_num = zeros(numel(num_clusters),1);

sdx = zeros(numel(num_clusters),1);
sdy = zeros(numel(num_clusters),1);

for i=1:num_clusters
    idx_use = find(r.frame==i);
    if isempty(idx_use)
        continue
    end
    
    x_use = x(idx_use);
    y_use = y(idx_use);
    z_use = z(idx_use);
    
    x_center = mean(x_use)/numel(idx_use);
    y_center = mean(y_use)/numel(idx_use);  
    x_shift = x_use-x_center;
    y_shift = y_use-y_center;
    [theta,radius] = cart2pol(x_shift,y_shift);
    radius_sort = sort(radius);
    radius_num = numel(radius_sort);
    out_radius(i) = radius_sort(round(radius_num*quantile));
    out_avgZ(i) = mean(z_use);
    out_stdZ(i) = std(z_use);
    out_num(i) = numel(idx_use);
    sdx(i) = std(x_use);
    sdy(i) = std(y_use);
end

%correct for empty clusters
out_idx = 1:numel(out_radius);
idx_delete = find(out_radius==0);
out_radius(idx_delete)=[];
idx_corrected = out_idx;
idx_corrected(idx_delete)=[];
sdx(idx_delete)=[];
sdy(idx_delete)=[];
out_stdZ(idx_delete)=[];
out_avgZ(idx_delete)=[];
out_num(idx_delete)=[];

smallROI_idx = find(out_radius<100);
smallROI_idx_corrected = 


%make circle plot
% th = 0:pi/50:2*pi;
% xcircle = out_radius(i)*cos(th)+x_center;
% ycircle = out_radius(i)*sin(th)+y_center;
% plot(x_center,y_center,'m+')
% hold on
% plot(x_use,y_use,'k.')
% plot(xcircle,ycircle)



%plot result
hist(out_radius,20)